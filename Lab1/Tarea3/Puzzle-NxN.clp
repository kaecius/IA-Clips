; (load Puzzle-NxN.clp)
; (BM (create$ 3 5 9 6 2 16 1 4 7 8 10 11 12 13 14 15 cop) anchura h-puzzle min TRUE)

(defglobal
    ?*ESTADO-INICIAL* = (create$)
    ?*PADRE* = ?*ESTADO-INICIAL*
    ?*LISTA* = (create$)
    ?*LISTA-F* = (create$)
    ?*LISTA-OPERADORES* = (create$)
    ?*DIMENSION* = 4
    ?*DIRECCION* = nil
    ?*SIMBOLO-HUECO* = 0
    ?*OPERADORES* = (create$ S E N O)
    ?*VISITADOS* = (create$)
    ?*FUNCION-H* = nil
    ?*CON-PROHIBIDO* = TRUE
    ?*CON-VISITADOS* = TRUE
    ?*GRAPH-FILE* = graph.gv
)

(deffunction modulo (?x $?y)
    (bind ?cociente (/ ?x (nth 1 $?y)))
    (integer (* (- ?cociente (integer ?cociente)) (nth 1 $?y)))
)

(deffunction posicion-hueca ($?estado)
    (member$ ?*SIMBOLO-HUECO* ?estado)
)

(deffunction extrae-puzzle ($?estado)
    (subseq$ $?estado 1 (- (member$ cop $?estado) 1))
)

(deffunction N ($?estado)
    (bind ?hueco (posicion-hueca ?estado))
    (if (<= ?hueco ?*DIMENSION*)
        then PROHIBIDO
        else (create$ (subseq$ ?estado 1 (- (- ?hueco ?*DIMENSION*) 1))
                      ?*SIMBOLO-HUECO* (subseq$ ?estado (+ (- ?hueco ?*DIMENSION*) 1) (- ?hueco 1))
                      (nth (- ?hueco ?*DIMENSION*) ?estado)
                      (subseq$ ?estado (+ ?hueco 1) (length$ ?estado)))
    )
)

(deffunction S ($?estado)
    (bind ?hueco (posicion-hueca ?estado))
    (if (> ?hueco (* ?*DIMENSION* (- ?*DIMENSION* 1)))
        then PROHIBIDO
        else (create$ (subseq$ ?estado 1 (- ?hueco 1))
                      (nth (+ ?hueco ?*DIMENSION*) ?estado)
                      (subseq$ ?estado (+ ?hueco 1) (- (+ ?hueco ?*DIMENSION*) 1))
                      ?*SIMBOLO-HUECO* (subseq$ ?estado (+ (+ ?hueco ?*DIMENSION*) 1) (length$ ?estado)))
    )
)

(deffunction O ($?estado)
    (bind ?hueco (posicion-hueca ?estado))
    (if (eq (modulo (- ?hueco 1) ?*DIMENSION*) 0)
        then PROHIBIDO
        else (create$ (subseq$ ?estado 1 (- ?hueco 2))
                      ?*SIMBOLO-HUECO* (nth (- ?hueco 1) ?estado)
                      (subseq$ ?estado (+ ?hueco 1) (length$ ?estado)))
    )
)

(deffunction E ($?estado)
    (bind ?hueco (posicion-hueca ?estado))
    (if (eq (modulo ?hueco ?*DIMENSION*) 0)
        then PROHIBIDO
        else (create$ (subseq$ ?estado 1 (- ?hueco 1))
                      (nth (+ ?hueco 1) ?estado) ?*SIMBOLO-HUECO*
                      (subseq$ ?estado (+ ?hueco 2) (length$ ?estado)))
    )
)

(deffunction exito ($?estado)
    (eval (format nil "(< %s)" (implode$ ?estado)))
)

(deffunction aplicar-operador (?operador $?estado)
	(funcall ?operador $?estado)
)

(deffunction prohibido? ($?estado)
  	(eq $?estado (create$ PROHIBIDO))
)

(deffunction hijos($?estado)
	(bind $?lista-hijos (create$))
    (bind $?costes (create$))
	(progn$ (?op ?*OPERADORES*) 
		(bind ?hijo (aplicar-operador ?op (extrae-puzzle ?estado)))
		(if (and (not (prohibido? ?hijo)) (or (not ?*CON-VISITADOS*) (and ?*CON-VISITADOS* (not (member$ (implode$ ?hijo) ?*VISITADOS*))))) then 
			(bind ?lista-hijos (create$ ?lista-hijos (implode$  (create$ ?hijo (subseq$ $?estado (member$ cop $?estado) (length$ $?estado)) ?op))))
            (bind ?costes (create$ ?costes (funcall ?*FUNCION-H* ?hijo)))
            (if (and (not (exito ?hijo)) ?*CON-VISITADOS*) ; Múltiples estados pueden desembocar en éxito
                then (bind ?*VISITADOS* (create$ ?*VISITADOS* (implode$ ?hijo)))
            )
		)
	)
    (if (eq ?*DIRECCION* anchura)
        then (bind ?*LISTA-F* (create$ ?*LISTA-F* ?costes))
        else (bind ?*LISTA-F* (create$ ?costes ?*LISTA-F*))
    )
	?lista-hijos
)

(deffunction h-puzzle ($?estado)
    (bind ?i 1)
    (bind ?descolocadas 0)
    (progn$ (?x ?estado)
        (if (not (eq ?i ?x))
            then (bind ?descolocadas (+ ?descolocadas 1))
        )
        (bind ?i (+ ?i 1))
    )
    ?descolocadas
)

(deffunction map2D ($?x)
    (bind ?cociente (/ (nth 1 $?x) ?*DIMENSION*))
    (bind ?coordX (integer ?cociente))
    (if (< ?coordX (/ (nth 1 $?x) ?*DIMENSION*))
        then (bind ?coordX (+ ?coordX 1))
             (bind ?coordY (modulo (nth 1 $?x) ?*DIMENSION*))
        else (bind ?coordY ?*DIMENSION*)
    )

    (create$ ?coordX ?coordY)
)

(deffunction manhattan ($?estado)
    (bind ?distance 0)
    (loop-for-count (?i 1 ?*DIMENSION*)
        (bind ?desiredCoords (map2D (nth ?i ?estado)))
        (bind ?currentCoords (map2D ?i))
        (bind ?offset (+ (abs (- (nth 1 ?desiredCoords) (nth 1 ?currentCoords))) (abs (- (nth 2 ?desiredCoords) (nth 2 ?currentCoords)))))
        (bind ?distance (+ ?distance ?offset))
    )
    ?distance
)

(deffunction state-to-str ($?estado)
    (bind ?res "n")
    (bind ?table "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">")
    (loop-for-count (?i 1 ?*DIMENSION*)
        (bind ?table (str-cat ?table "<tr>"))
        (loop-for-count (?j 1 ?*DIMENSION*)
            (bind ?number (nth (+ (* (- ?i 1) ?*DIMENSION*) ?j) ?estado))
            (if (eq ?number ?*SIMBOLO-HUECO*)
                then (bind ?number "X")
                     (bind ?table (str-cat ?table "<td><font color=\"red\">" ?number "</font></td>"))
                else (bind ?table (str-cat ?table "<td>" ?number "</td>"))
            )
            (bind ?res (str-cat ?res ?number "_"))
        )
        (bind ?table (str-cat ?table "</tr>"))
    )
    (bind ?res (sub-string 1 (- (str-length ?res) 1) ?res))
    (bind ?table (str-cat ?table "</table>>"))
    (create$ ?res ?table)
)

(deffunction BM (?edo-inicial ?direccion ?funcion ?optimizador $?visitados)
    (printout t "Introduzca el nombre del fichero en el que se escribirá el árbol: ")
	(bind ?file (read))
	(open ?file ?*GRAPH-FILE* "a")
	(printout ?*GRAPH-FILE* "digraph G {" crlf)
    (bind ?*ESTADO-INICIAL* ?edo-inicial)
    (bind ?*PADRE* ?*ESTADO-INICIAL*)
    (bind ?*FUNCION-H* ?funcion)
    (bind ?*SIMBOLO-HUECO* (length$ (extrae-puzzle ?*ESTADO-INICIAL*)))
    (bind ?*DIMENSION* (integer (sqrt ?*SIMBOLO-HUECO*)))
    (bind ?*LISTA* (create$ (implode$ ?*ESTADO-INICIAL*)))
    (bind ?*LISTA-F* (create$ (funcall ?*FUNCION-H* (extrae-puzzle ?*ESTADO-INICIAL*))))
    (bind ?*CON-VISITADOS* (nth 1 $?visitados))
    (bind ?*DIRECCION* ?direccion)
    (bind ?*VISITADOS* (create$ (implode$ (extrae-puzzle ?*ESTADO-INICIAL*))))
    (bind ?best-solution (create$))
    (bind ?padre-str (state-to-str ?*PADRE*))
	(format ?*GRAPH-FILE* "    n0 [label=\"\", shape=none, height=.0, width=.0];%n    n0 -> %s;%n" (nth 1 ?padre-str))
    (if (eq (length$ (extrae-puzzle ?*ESTADO-INICIAL*)) (* ?*DIMENSION* ?*DIMENSION*))
        then (bind ?i 1)  ; Board dimensions are OK
             (while (not (eq ?*LISTA* (create$))) do
                 (if (eq (length$ ?*LISTA-F*) 1) ; min and max functions expect at least 2 arguments
                    then (bind ?next-father 1)
                    else (bind ?next-father (eval (format nil "(member$ (%s %s) ?*LISTA-F*)" ?optimizador (implode$ ?*LISTA-F*))))
                 )
                 (bind ?*PADRE* (explode$ (nth ?next-father ?*LISTA*)))
                 (bind ?*LISTA* (create$ (subseq$ ?*LISTA* 1 (- ?next-father 1)) (subseq$ ?*LISTA* (+ ?next-father 1) (length$ ?*LISTA*))))
                 (bind ?*LISTA-F* (create$ (subseq$ ?*LISTA-F* 1 (- ?next-father 1)) (subseq$ ?*LISTA-F* (+ ?next-father 1) (length$ ?*LISTA-F*))))
                 (bind ?padre-str (state-to-str ?*PADRE*))
                 
                 (if (eq ?i 1) 
                    then (format ?*GRAPH-FILE* "    %s [fillcolor=yellow, style=filled, shape=none, label=%s];%n" (nth 1 ?padre-str) (nth 2 ?padre-str))
                 )

                 (if (eq (modulo ?i 200) 0) then (printout t "Paso " ?i ": " ?*PADRE* crlf))

                 (if (not (exito (extrae-puzzle ?*PADRE*))) 
                    then (bind ?hijos (hijos ?*PADRE*))
                         (progn$ (?h ?hijos)
                            (bind ?h-str (state-to-str (extrae-puzzle (explode$ ?h))))
                            (format ?*GRAPH-FILE* "    %s [shape=none, label=%s];%n" (nth 1 ?h-str) (nth 2 ?h-str))
                            (format ?*GRAPH-FILE* "    %s -> %s [label=\"%s\"];%n" (nth 1 ?padre-str) (nth 1 ?h-str) (nth (length$ (explode$ ?h)) (explode$ ?h)))
                         )
                         (if (eq ?direccion profundidad)
                             then (bind ?*LISTA* (create$ ?hijos ?*LISTA*))
                             else (bind ?*LISTA* (create$ ?*LISTA* ?hijos))
                         )
                    else (if (< (length$ ?*PADRE*) (length$ ?best-solution))
                            then (format ?*GRAPH-FILE* "    %s [fillcolor=aquamarine, style=filled];%n" (nth 1 (state-to-str (extrae-puzzle ?*PADRE*))))
                                 (bind ?best-solution ?*PADRE*)
                            else (if (eq ?best-solution (create$))
                                     then (bind ?best-solution ?*PADRE*)
                                 )
                         )
                         (format t "%nSOLUCIÓN PARCIAL: %s%n" (implode$ ?best-solution))
                 )
                 (bind ?i (+ ?i 1))
             )
 
             (if  (exito (extrae-puzzle ?best-solution))
                 then (printout t "La solución es: " (subseq$ ?best-solution (+ (member$ cop ?best-solution) 1) (length$ ?best-solution)) crlf)
                      (format ?*GRAPH-FILE* "    %s [fillcolor=green, style=filled];%n" (nth 1 (state-to-str ?best-solution)))
                 else (if (=(length$ ?*LISTA*)0)  then (printout t "No hay solución" crlf))
             )
        else (printout t "Dimensión del tablero incorrecta." crlf)
    )
    (printout ?*GRAPH-FILE* } crlf)
    (close ?*GRAPH-FILE*)
)